<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>auto_rate: Performance in detecting linear regions • respR</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="auto_rate: Performance in detecting linear regions">
<meta property="og:description" content="respR">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">respR</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.1.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa-home"></span>
     
  </a>
</li>
<li>
  <a href="../articles/respR.html">Getting Started</a>
</li>
<li>
  <a href="../reference/index.html">List of Functions</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Documentation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/importing.html">Importing your data</a>
    </li>
    <li>
      <a href="../articles/auto_rate.html">auto_rate: Automatic detection of linear rates</a>
    </li>
    <li>
      <a href="../articles/closed.html">Closed-chamber respirometry</a>
    </li>
    <li>
      <a href="../articles/intermittent.html">Intermittent-flow respirometry: Simple example</a>
    </li>
    <li>
      <a href="../articles/intermittent2.html">Intermittent-flow respirometry: Complex example</a>
    </li>
    <li>
      <a href="../articles/flowthrough.html">Flowthrough respirometry</a>
    </li>
    <li>
      <a href="../articles/pcrit.html">Pcrit analysis</a>
    </li>
    <li>
      <a href="../articles/twopoint.html">Two-point analysis</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Discussion
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/auto_rate_performance.html">auto_rate: Performance in detecting linear regions</a>
    </li>
    <li>
      <a href="../articles/auto_rate_comp.html">auto_rate: Comparisons with LoLinR</a>
    </li>
    <li>
      <a href="../articles/packages_comp.html">respR: Comparisons with other R packages</a>
    </li>
    <li>
      <a href="../articles/tidyverse.html">respR: Integration with the tidyverse</a>
    </li>
    <li>
      <a href="../articles/reproducibility.html">respR: Reporting reproducible analyses</a>
    </li>
    <li>
      <a href="../articles/usage.html">respR: When to use respR</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/januarharianto/respr/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="auto_rate_performance_files/header-attrs-2.8/header-attrs.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>auto_rate: Performance in detecting linear regions</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/januarharianto/respr/blob/master/vignettes/auto_rate_performance.Rmd"><code>vignettes/auto_rate_performance.Rmd</code></a></small>
      <div class="hidden name"><code>auto_rate_performance.Rmd</code></div>

    </div>

    
    
<p>The function <code>auto_rate</code> uses rolling regression and kernel density estimation techniques to automatically detect the <em>most linear</em> regions in respirometry data. The dimensionless nature of the function, however, also allows it to be applied to any serial data.</p>
<p>To our knowledge, the methods we use here are novel, and not reported in past publications involving linear data detection and analysis of biological data. <a href="http://doi.org/10.1242/jeb.148775">Olito et al. (2016)</a> describes a different, though robust, method to detect and rank linear segments in data using their R package, <code>LoLinR</code>. A comparison of <code>auto_rate</code> and <code>LoLinR</code>’s methods are shown <a href="https://januarharianto.github.io/respR/articles/auto_rate_comp.html">here</a>.</p>
<p>The performance tests that we present here are limited but comprehensive, and provide a starting point in generating the data necessary for users to make informed decisions on using and further testing <code>auto_rate</code> for their own purposes. <strong>Users should be aware</strong> that noisy, strongly fluctuating data could cause unpredictable, unwanted results to be returned. For example, while we have had generally good results with our own data, intermittent flow respirometry data where O2 is fluctuating up and down between periods of use by the specimens and flushing the respirometry chamber are likely to confuse the algorithms. Users should always examine the outputs of <code>auto_rate</code> (and indeed other functions in <code>respR</code>) to understand where returned results occur within the data and that they are representative of the question of interest. We have made this as easy as possible, and designed the package specifically to not be a ‘black box’ and at every stage make the user aware of what is going on through plotting results and their locations in the context of the entire datasets, and in the console outputs.</p>
<div id="testing-the-linear-detection-method-of-auto_rate" class="section level2">
<h2 class="hasAnchor">
<a href="#testing-the-linear-detection-method-of-auto_rate" class="anchor"></a>Testing the linear detection method of auto_rate</h2>
<p>To ensure that <code>auto_rate</code> performs as intended, we created two internal functions designed to test the accuracy of our KDE techniques to detect linear data. The first function, <code><a href="../reference/sim_data.html">sim_data()</a></code>, generates a random dataset which contains both linear and non-linear segments. The second function, <code><a href="../reference/test_lin.html">test_lin()</a></code>, specifically performs <code>auto_rate</code> repeatedly on randomly generated data and aggregates the performance metrics obtained to assess and visualise the accuracy of the KDE technique. Both functions are published with the <code>respR</code> package, thus anyone can use them – as we show below – or run them with their own input paramters.</p>
</div>
<div id="generating-simulated-data-for-tests" class="section level2">
<h2 class="hasAnchor">
<a href="#generating-simulated-data-for-tests" class="anchor"></a>Generating simulated data for tests</h2>
<p><code><a href="../reference/sim_data.html">sim_data()</a></code> is used to randomly generate three kinds of data based on the <code>method</code> argument, which we briefly describe below. It accepts inputs to customise the length of the data (no. of samples), the type of data (described below), the degree of noise as specified by the standard deviation of the data (default 0.05), and a preview toggle to plot and visualise the simulated dataset.</p>
<div id="default-data" class="section level3">
<h3 class="hasAnchor">
<a href="#default-data" class="anchor"></a>“Default” data</h3>
<p><code><a href="../reference/sim_data.html">sim_data(method = "default")</a></code></p>
<p>A non-linear segment is first generated using a sine or cosine function with a random length of <code><a href="https://rdrr.io/r/base/Round.html">floor(abs(rnorm(1, .25*len, .05*len)))</a></code>, where <code>len</code> is the total number of observations in the data defined in the function argument, and a random amplitude of <code><a href="https://rdrr.io/r/stats/Normal.html">rnorm(1, .8, .05)</a></code>. This data segment is appended to a linear segment with a randomly-generated slope computed using <code><a href="https://rdrr.io/r/stats/Normal.html">rnorm(1, 0, 0.02)</a></code>. The shape of the dataset is designed to mimic common respirometry data whereby the initial sections of the data are often non-linear. Here we show 25 randomly-generated plots created by the method:</p>
<p><img src="auto_rate_performance_files/figure-html/defaultdata-1.png" width="576"></p>
</div>
<div id="corrupted-data" class="section level3">
<h3 class="hasAnchor">
<a href="#corrupted-data" class="anchor"></a>“Corrupted” data</h3>
<p><code><a href="../reference/sim_data.html">sim_data(method = "corrupted")</a></code></p>
<p>Same as <code>"default"</code>, but “corrupted” data is inserted randomly at any point in the linear segment. The data corruption is depicted by a sudden dip in the reading, which recovers. This event mimics equipment interference that does not necessarily invalidate the dataset if the corrupted section is omitted from analysis. The dip is generated by a cosine function of fixed amplitude of 1, and the length is randomly generated using <code><a href="https://rdrr.io/r/base/Round.html">floor(rnorm(1, .25 * len_x, .02 * len_x))</a></code>, where <code>len_x</code> is the length of the linear segment.</p>
<p>Thus, to detect the valid linear segment, <code>auto_rate</code> will need to omit the initial non-linear segment, ignore the dip, and then pick the longer of the 2 remaining linear segments that are separated by the dip. Here we show 25 randomly-generated plots created by the method:</p>
<p><img src="auto_rate_performance_files/figure-html/corruptdata-1.png" width="576"></p>
</div>
<div id="segmented-data" class="section level3">
<h3 class="hasAnchor">
<a href="#segmented-data" class="anchor"></a>“Segmented” data</h3>
<p><code><a href="../reference/sim_data.html">sim_data(method = "segmented")</a></code></p>
<p>Same as <code>"default"</code>, but the data is modified to contain two linear segments. The slope of the second linear segment is randomly chosen at approximately 0.5<span class="math inline">\(\times\)</span> to 0.6<span class="math inline">\(\times\)</span> of the first linear segment (i.e the slope is always a magnitude smaller than the first linear segment).</p>
<p>Thus, to detect the correct linear segment, <code>auto_rate</code> would need to correctly omit the initial non-linear segment, and also, ignore the end segment of the data as it has a different slope. Here we show 25 randomly-generated plots created by the method:</p>
<p><img src="auto_rate_performance_files/figure-html/segdata-1.png" width="576"></p>
</div>
</div>
<div id="test-conditions" class="section level2">
<h2 class="hasAnchor">
<a href="#test-conditions" class="anchor"></a>Test conditions</h2>
<p>To quantify the performance and accuracy of <code>auto_rate</code>’s linear detection technique, the function <code><a href="../reference/test_lin.html">test_lin()</a></code> runs the linear detection technique (<code>method = "linear"</code>) iteratively and extracts specific output parameter for analysis. The parameters include:</p>
<ol style="list-style-type: decimal">
<li>The length of the true segment (<span class="math inline">\(len_t\)</span>);</li>
<li>The length of the detected segment that is correctly sampled (<span class="math inline">\(len_c\)</span>). Here, we also call such data “true”;</li>
<li>The length of the detected segment that is <em>incorrectly</em> sampled (<span class="math inline">\(len_i\)</span>). Here, we also call such data “other”;</li>
<li>The slope of the true segment (<span class="math inline">\(\beta_{true}\)</span>, or true rate); and</li>
<li>The slope of the detected segment (<span class="math inline">\(\beta_{detected}\)</span>, or detected rate).</li>
</ol>
<p>From the above data, we can generate four kinds of performance metrics for visualisation:</p>
<ol style="list-style-type: decimal">
<li>A density plot of the proportion of the linear segment correctly identified. Each data point is a measure of <span class="math inline">\({len_c}\div{len_t}\)</span>.</li>
<li>A density plot of the proportion of incorrectly-sampled data. Each data point is a measure of <span class="math inline">\({len_i}\div{len_c}\)</span>.</li>
<li>A linear regression plot, where each data point is a measure of of <span class="math inline">\(\beta_{detected}\)</span> (y) as a function of <span class="math inline">\(\beta_{true}\)</span> (x);</li>
<li>An x-y plot of the deviation between <span class="math inline">\(\beta_{detected}\)</span> and <span class="math inline">\(\beta_{true}\)</span>. Each data point is a measure of <span class="math inline">\(\beta_{true} - \beta_{detected}\)</span>.</li>
</ol>
<p>We performed <code><a href="../reference/test_lin.html">test_lin()</a></code> with 1,000 iterations, for all of the three kinds of data produced by <code><a href="../reference/sim_data.html">sim_data()</a></code> (<code>"default", "corrupted"</code>, and <code>"segmented"</code>). To check performance on different data lengths, we repeated the tests using 100, 200 and 500 data points. The output of our performance test is avaliable from within the package as a data object called <code>test_lin_data</code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># NOTE: Functions take some time to run</span>

<span class="co"># Test on data of length 100 samples -------------------------------------------</span>
<span class="co"># This performs 1,000 iterations of auto_rate on a "default"-type data</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span>
<span class="va">default100</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_lin.html">test_lin</a></span><span class="op">(</span>reps <span class="op">=</span> <span class="fl">1000</span>, len <span class="op">=</span> <span class="fl">100</span>, type <span class="op">=</span> <span class="st">"default"</span><span class="op">)</span>

<span class="co"># This performs 1,000 iterations of auto_rate on a "corrupted"-type data</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">456</span><span class="op">)</span>
<span class="va">corrupted100</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_lin.html">test_lin</a></span><span class="op">(</span>reps <span class="op">=</span> <span class="fl">1000</span>, len <span class="op">=</span> <span class="fl">100</span>, type <span class="op">=</span> <span class="st">"corrupted"</span><span class="op">)</span>

<span class="co"># This performs 1,000 iterations of auto_rate on a "segmented"-type data</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">789</span><span class="op">)</span>
<span class="va">segmented100</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_lin.html">test_lin</a></span><span class="op">(</span>reps <span class="op">=</span> <span class="fl">1000</span>, len <span class="op">=</span> <span class="fl">100</span>, type <span class="op">=</span> <span class="st">"segmented"</span><span class="op">)</span>

<span class="co"># Test on data of length 200 samples -------------------------------------------</span>
<span class="co"># This performs 1,000 iterations of auto_rate on a "default"-type data</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span>
<span class="va">default200</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_lin.html">test_lin</a></span><span class="op">(</span>reps <span class="op">=</span> <span class="fl">1000</span>, len <span class="op">=</span> <span class="fl">200</span>, type <span class="op">=</span> <span class="st">"default"</span><span class="op">)</span>

<span class="co"># This performs 1,000 iterations of auto_rate on a "corrupted"-type data</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">456</span><span class="op">)</span>
<span class="va">corrupted200</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_lin.html">test_lin</a></span><span class="op">(</span>reps <span class="op">=</span> <span class="fl">1000</span>, len <span class="op">=</span> <span class="fl">200</span>, type <span class="op">=</span> <span class="st">"corrupted"</span><span class="op">)</span>

<span class="co"># This performs 1,000 iterations of auto_rate on a "segmented"-type data</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">789</span><span class="op">)</span>
<span class="va">segmented200</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_lin.html">test_lin</a></span><span class="op">(</span>reps <span class="op">=</span> <span class="fl">1000</span>, len <span class="op">=</span> <span class="fl">200</span>, type <span class="op">=</span> <span class="st">"segmented"</span><span class="op">)</span>

<span class="co"># Test on data of length 500 samples -------------------------------------------</span>
<span class="co"># This performs 1,000 iterations of auto_rate on a "default"-type data</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span>
<span class="va">default500</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_lin.html">test_lin</a></span><span class="op">(</span>reps <span class="op">=</span> <span class="fl">1000</span>, len <span class="op">=</span> <span class="fl">500</span>, type <span class="op">=</span> <span class="st">"default"</span><span class="op">)</span>

<span class="co"># This performs 100 iterations of auto_rate on a "corrupted"-type data</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">456</span><span class="op">)</span>
<span class="va">corrupted500</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_lin.html">test_lin</a></span><span class="op">(</span>reps <span class="op">=</span> <span class="fl">1000</span>, len <span class="op">=</span> <span class="fl">500</span>, type <span class="op">=</span> <span class="st">"corrupted"</span><span class="op">)</span>

<span class="co"># This performs 100 iterations of auto_rate on a "segmented"-type data</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">789</span><span class="op">)</span>
<span class="va">segmented500</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_lin.html">test_lin</a></span><span class="op">(</span>reps <span class="op">=</span> <span class="fl">1000</span>, len <span class="op">=</span> <span class="fl">500</span>, type <span class="op">=</span> <span class="st">"segmented"</span><span class="op">)</span></code></pre></div>
</div>
<div id="how-do-i-know-if-the-tests-are-actually-running-and-detecting-segments" class="section level2">
<h2 class="hasAnchor">
<a href="#how-do-i-know-if-the-tests-are-actually-running-and-detecting-segments" class="anchor"></a>How do I know if the tests are actually running and detecting segments?</h2>
<p><code><a href="../reference/test_lin.html">test_lin()</a></code> can perform tests in a very cool and visual way – at the cost of speed. The argument <code>plot</code>, when set to TRUE, can show us exactly the detected segments at every iteration. Try it!</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Try this code below. WARNING: Will run and plot visuals 20 times.</span>
<span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/test_lin.html">test_lin</a></span><span class="op">(</span>reps <span class="op">=</span> <span class="fl">20</span>, len <span class="op">=</span> <span class="fl">500</span>, type <span class="op">=</span> <span class="st">"segmented"</span>, plot <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
</div>
<div id="results" class="section level2">
<h2 class="hasAnchor">
<a href="#results" class="anchor"></a>Results</h2>
<div id="default-data-1" class="section level3">
<h3 class="hasAnchor">
<a href="#default-data-1" class="anchor"></a>“Default” data</h3>
<p>Results were very encouraging; when run on data with 100 samples, <strong>(A)</strong> <code>auto_rate</code> correctly detected a large proportion of the true segment in general, and <strong>(B)</strong> incorrectly sampled only a small amount of other data. <strong>(C)</strong> Comparison of <span class="math inline">\(\beta_{detected}\)</span> against <span class="math inline">\(\beta_{true}\)</span> showed very stable detection across all slopes, even when slope values approached zero. This was evident in <strong>(D)</strong> where roughly, the maximum <span class="math inline">\(\beta_{detected}\)</span> values had <span class="math inline">\(\pm 0.004\)</span> deviation from the <span class="math inline">\(\beta_{detected}\)</span> values across all values of <span class="math inline">\(\pm 0.06\)</span>, even for values close to zero:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">test_lin_data</span><span class="op">$</span><span class="va">default100</span><span class="op">)</span></code></pre></div>
<p><img src="auto_rate_performance_files/figure-html/plotdefault100-1.png" width="576"></p>
<p>Tests on larger sample data sizes of 200 and 500 revealed that <code>auto_rate</code> performed better when provided with bigger data. When used on data with 500 samples, <code>auto_rate</code> generally <strong>(A)</strong> detected a larger proportion of the true data and <strong>(B)</strong> was less prone to sampling incorrect portions of the data. <strong>(C)</strong> Linear regression had a <span class="math inline">\(R^2\)</span> of 0.999, and <strong>(D)</strong> deviation was 10<span class="math inline">\(\times\)</span> smaller than when sample size was at 100:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">test_lin_data</span><span class="op">$</span><span class="va">default500</span><span class="op">)</span></code></pre></div>
<p><img src="auto_rate_performance_files/figure-html/plotdefault500-1.png" width="576"></p>
</div>
<div id="corrupted-data-1" class="section level3">
<h3 class="hasAnchor">
<a href="#corrupted-data-1" class="anchor"></a>“Corrupted” data</h3>
<p>In this challenging data scenario <code>auto_rate</code> had a tendency to under-sample the linear segment. As this particular type of data consisted of two linear segments separated by a “dip”, the function also sometimes <strong>(A)</strong> detected the shorter segment as the top-ranked result, resulting in the correct estimate of <span class="math inline">\(\beta_{true}\)</span>, but the wrong linear segment detected. Thus, the function may incorrectly sample none of the linear segment <strong>(B)</strong>, but only rarely; in most cases, it still identified the right segment, and incorrectly sampled only a small amount of data. <strong>(C)</strong> Comparison of <span class="math inline">\(\beta_{detected}\)</span> against <span class="math inline">\(\beta_{true}\)</span> showed stable, but relatively noisy detection of the true rate across all slopes when compared to its performance with “default”-type data. <strong>(D)</strong> The deviation plot showed that performance was genrally poorer at values close to zero.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">test_lin_data</span><span class="op">$</span><span class="va">corrupted100</span><span class="op">)</span></code></pre></div>
<p><img src="auto_rate_performance_files/figure-html/plotcorrupted100-1.png" width="576"></p>
<p>Again, <code>auto_rate</code> performed better when provided with bigger data. At 500 samples the same issue where the shorter linear segment was incorrectly selected still persisted <strong>(A)</strong>, but <strong>(B)</strong> the function sampled incorrect segments less often, <strong>(C)</strong> linear regression of <span class="math inline">\(\beta_{detected}\)</span> against <span class="math inline">\(\beta_{true}\)</span> had a better goodness of fit and <strong>(D)</strong> deviation values from <span class="math inline">\(\beta_{true}\)</span> were substantially smaller with seemingly fewer poor estimates when slope values approach zero.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">test_lin_data</span><span class="op">$</span><span class="va">corrupted500</span><span class="op">)</span></code></pre></div>
<p><img src="auto_rate_performance_files/figure-html/plotcorrupted500-1.png" width="576"></p>
</div>
<div id="segmented-data-1" class="section level3">
<h3 class="hasAnchor">
<a href="#segmented-data-1" class="anchor"></a>“Segmented” data</h3>
<p>This type of data is the most difficult to handle as <code>auto_rate</code> needed to disregard the curved, but increasingly-linear top portion of the data, and also discard the slight degree of change in slope towards the end of the data. Thus, <code>auto_rate</code> performed well in many cases, but poorly in others. In the majority of cases, <strong>(A)</strong> when it managed to sample the linear segment, it did so for a very large fraction of the data. <strong>(B)</strong> It performed less well at avoiding incorrect sampling, since it sometimes selected the other linear segment. However, <strong>(C)</strong> the plot of <span class="math inline">\(\beta_{detected}\)</span> against <span class="math inline">\(\beta_{true}\)</span> showed that it still performed surprisingly well most of the time, despite the errors, and <strong>(D)</strong> the deviance from the true rate appeared to be poorer when slope values are closer to zero.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">test_lin_data</span><span class="op">$</span><span class="va">segmented100</span><span class="op">)</span></code></pre></div>
<p><img src="auto_rate_performance_files/figure-html/plotsegmented100-1.png" width="576"></p>
<p>Again, with a larger dataset, <code>auto_rate</code>’s performance was substantially better. With a 500-sample dataset, many of the issues that occured in the previous test were better resolved. The function <strong>(A)</strong> correctly sampled the right segment most of the time, and rarely sampled other data or the other linear segment <strong>(B)</strong>. <strong>(C)</strong> Linear regression of <span class="math inline">\(\beta_{detected}\)</span> against <span class="math inline">\(\beta_{true}\)</span> had a <span class="math inline">\(R^2\)</span> of 0.999, and <strong>(D)</strong> deviations from <span class="math inline">\(\beta_{true}\)</span> were much smaller in magnitude.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">test_lin_data</span><span class="op">$</span><span class="va">segmented500</span><span class="op">)</span></code></pre></div>
<p><img src="auto_rate_performance_files/figure-html/plotsegmented500-1.png" width="576"></p>
<p>We did not report any of the results for 200-sample size datasets, but users are free to call the data object <code>test_lin_data</code> and plot the results, or run their own analyses using the functions we provide.</p>
</div>
</div>
<div id="summary" class="section level2">
<h2 class="hasAnchor">
<a href="#summary" class="anchor"></a>Summary</h2>
<p>In this limited testing on relatively small datasets, we have shown that on datasets of around 100 records in length <code>auto_rate</code> performs quite well, although with some occurences of data mischaracterisation. However, when datasets are around 500 in length its performance is radically improved. This pattern holds across our three test data types characteristic of respirometry data: <code>"default"</code> (non-linear to linear data segments), <code>"corrupted"</code> (data with an obvious erroneous drop-out), and <code>"segmented"</code> (non-linear to multiple linear segments). The use of <code>auto_rate</code> on datasets larger than this is likely to be even more accurate in identifying valid linear regions of data.</p>
<p>Despite the overall good perfomance, this does serve to illustrate that users should always inspect and explore their data, and the results of analyses for obvious errors and that the results are characteristic and valid answers to the question they are asking of the data. We have this made this as straightforward as possible in <code>respR</code> through always outputting by default plots with results highlighted in the context of the entire datasets, and useful summary output in the console. There is also extensive support for exploring data and results via the base R <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code>, <code><a href="https://rdrr.io/r/base/print.html">print()</a></code> and <code><a href="https://rdrr.io/r/base/summary.html">summary()</a></code> functions.</p>
</div>
<div id="references" class="section level2">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<p>Olito, C., White, C. R., Marshall, D. J., &amp; Barneche, D. R. (2017). Estimating monotonic rates from biological data using local linear regression. The Journal of Experimental Biology, jeb.148775-jeb.148775. <a href="http://doi.org/10.1242/jeb.148775" class="uri">http://doi.org/10.1242/jeb.148775</a></p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Januar Harianto, Nicholas Carey.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
