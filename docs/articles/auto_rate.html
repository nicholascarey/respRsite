<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>auto_rate: Automatic detection of metabolic rates • respR</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="auto_rate: Automatic detection of metabolic rates">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">respR</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.1.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="../articles/respR.html">Getting Started</a>
</li>
<li>
  <a href="../reference/index.html">List of Functions</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Documentation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/importing.html">Importing your data</a>
    </li>
    <li>
      <a href="../articles/auto_rate.html">auto_rate: Automatic detection of linear rates</a>
    </li>
    <li>
      <a href="../articles/closed.html">Closed-chamber respirometry</a>
    </li>
    <li>
      <a href="../articles/intermittent.html">Intermittent-flow respirometry: Simple example</a>
    </li>
    <li>
      <a href="../articles/intermittent2.html">Intermittent-flow respirometry: Complex example</a>
    </li>
    <li>
      <a href="../articles/flowthrough.html">Flowthrough respirometry</a>
    </li>
    <li>
      <a href="../articles/pcrit.html">Pcrit analysis</a>
    </li>
    <li>
      <a href="../articles/twopoint.html">Two-point analysis</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Discussion
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/performance.html">auto_rate: Performance in detecting linear regions</a>
    </li>
    <li>
      <a href="../articles/auto_rate_comp.html">auto_rate: Comparisons with LoLinR</a>
    </li>
    <li>
      <a href="../articles/packages_comp.html">respR: Comparisons with other R packages</a>
    </li>
    <li>
      <a href="../articles/tidyverse.html">respR: Integration with the tidyverse</a>
    </li>
    <li>
      <a href="../articles/reproducibility.html">respR: Reporting reproducible analyses</a>
    </li>
    <li>
      <a href="../articles/usage.html">respR: When to use respR</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/januarharianto/respr">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="auto_rate_files/header-attrs-2.1/header-attrs.js"></script><script src="auto_rate_files/htmlwidgets-1.5.1/htmlwidgets.js"></script><script src="auto_rate_files/viz-1.8.2/viz.js"></script><link href="auto_rate_files/DiagrammeR-styles-0.2/styles.css" rel="stylesheet">
<script src="auto_rate_files/grViz-binding-1.0.5/grViz.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>auto_rate: Automatic detection of metabolic rates</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/januarharianto/respr/blob/master/vignettes/auto_rate.Rmd"><code>vignettes/auto_rate.Rmd</code></a></small>
      <div class="hidden name"><code>auto_rate.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>In respirometry, we often want to report oxygen uptake rates that represent experimentally important stages or physiological states. These include:</p>
<ul>
<li>the most consistent (i.e. most linear) rates observed, often most representative of <em>routine</em> metabolism</li>
<li>minimum rates observed, often most representative of <em>standard</em>, <em>resting</em>, <em>basal</em> or <em>maintenance</em> metabolism</li>
<li>maximum rates observed, representative of <em>active</em> or <em>maximum</em> metabolic rates</li>
</ul>
<p>The problem is that for large datasets, identifying these regions is difficult, and if selected visually, are subject to bias and lack of observer objectivity. Other methods, such as fitting multiple, fixed-width linear regressions over the entire dataset to identify regions of minimum or maximum slopes is computationally intensive, and slopes found via this method highly sensitive to the width chosen, especially if the specimen’s metabolic rate changes rapidly.</p>
<p>Here we present <code><a href="../reference/auto_rate.html">auto_rate()</a></code>, a function in the <code>respR</code> package that uses rolling regression techniques to automatically detect <strong>most linear</strong>, <strong>maximum</strong> and <strong>minimum</strong> rates within a dataset in a statistically robust, objective manner.</p>
<p>In this vignette we detail how <code><a href="../reference/auto_rate.html">auto_rate()</a></code> works, and how it can be used to extract rates from respirometry data. In additional vignettes we show how we have <a href="https://januarharianto.github.io/respR/articles/performance.html">tested this method against simulated data</a>, and also <a href="https://januarharianto.github.io/respR/articles/auto_rate_comp.html">compare its performance against another linear detection method</a>. We show it performs extremely well on large datasets in determining linear rates. Importantly, <code><a href="../reference/auto_rate.html">auto_rate()</a></code> has been optimised to be <em>extremely fast</em>. Other methods on large datasets can take minutes, hours or even <em>days</em> to run. We show how <code><a href="../reference/auto_rate.html">auto_rate()</a></code> can reduce this wait by orders of magnitude, literally fitting tens of thousands of regressions and detecting linear regions in seconds.</p>
</div>
<div id="overview" class="section level2">
<h2 class="hasAnchor">
<a href="#overview" class="anchor"></a>Overview</h2>
<p>This illustrates the main processes involved in <code><a href="../reference/auto_rate.html">auto_rate()</a></code>:</p>
<div id="htmlwidget-896cd39b8500446ec44f" style="width:576px;height:576px;" class="grViz html-widget"></div>
<script type="application/json" data-for="htmlwidget-896cd39b8500446ec44f">{"x":{"diagram":"\ndigraph a_nice_graph {\n\n# node definitions with substituted label text\n\nnode [fontname = Helvetica, shape = circle]\nrd [label = \"Raw Data\"]\n\nnode [fontname = Helvetica, shape = rectangle]\nrr [label = \"1. Rolling linear regression\"]\nkd [label = \"2. Kernel density\nestimates\"]\nre [label = \"3. Bandwidth resampling\"]\nlr [label = \"4. Linear regression\"]\nar [label = \"5. Rank\"]\nfi [label = \"6. Filter\"]\n\nnode [fontname = Menlo, shape = none]\nau [label = \"auto_rate()\"]\nli [label = \"linear,\"]\nmm [label = \"max, min\"]\nin [label = \"interval\"]\n\n# edge definitions with the node IDs\n\nrd -> au -> rr -> ar -> mm\nrr -> kd -> re -> lr -> ar -> li\nrr -> fi -> in\n\n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script><p><code><a href="../reference/auto_rate.html">auto_rate()</a></code> works by performing an optimised rolling regression on the dataset. A kernel density estimate is performed on the rolling regression output and the kernel bandwidth used to re-sample linear regions of the data for re-analysis.</p>
</div>
<div id="rolling-linear-regression" class="section level2">
<h2 class="hasAnchor">
<a href="#rolling-linear-regression" class="anchor"></a>Rolling linear regression</h2>
<p>The function <code><a href="../reference/auto_rate.html">auto_rate()</a></code> uses a novel method of combining rolling regression and kernel density estimate algorithms to detect patterns in time series data. The rolling regression runs all possible ordinary least-squares (OLS) linear regressions <span class="math inline">\((y = \beta_0 + \beta_1 X + \epsilon)\)</span> of a fixed sample width across the dataset, and is expressed as: <span class="math display">\[y_t(n) = X_t(n) \beta (n) + \epsilon_t(n), \ t = n,\ ...,\ T\]</span> where <span class="math inline">\(T\)</span> is the total length of the dataset, <span class="math inline">\(n\)</span> is the window of width <span class="math inline">\(n &lt; T\)</span>, <span class="math inline">\(y_t(n)\)</span> is the vector of observations (e.g. oxygen concentration), <span class="math inline">\(X_t(n)\)</span> is the matrix of explanatory variables, <span class="math inline">\(\beta (n)\)</span> is a vector of regression parameters and <span class="math inline">\(\epsilon_t(n)\)</span> is a vector of error terms. Thus, a total of <span class="math inline">\((T - n) + 1\)</span> number of overlapping regressions are fit. These are then ranked to obtain maximum and minimum values. An interval-based rolling regression can be selected (<code>method = "interval"</code>), and it automatically selects non-overlapping sections of the data for regressions, but all other methods fit overlapping regressions.</p>
</div>
<div id="kernel-density-estimation" class="section level2">
<h2 class="hasAnchor">
<a href="#kernel-density-estimation" class="anchor"></a>Kernel density estimation</h2>
<!-- Additional methods are automatically applied when we use `auto_rate()` to detect linear sections of the data.  -->
<!-- First, a Gaussian kernel density estimate (KDE) is used to process the regression coefficient $\beta$, based on the key assumption that linear sections of the data are reflected by relatively stable parameters across the rolling estimates. -->
<!-- This assumption is used often in financial statistics to evaluate stability and make predictions on time-series data. -->
<!-- Here, KDE automatically aggregates stable (i.e. linear) sections as they naturally form one or more local maximums ("modes") in the probability density estimate, and if the distribution is multimodal, the modes are ranked by size. -->
<p>Additional analytical techniques are automatically applied when we use <code><a href="../reference/auto_rate.html">auto_rate()</a></code> to detect linear sections of the data (the default of <code>method = 'linear'</code>). First, we take advantage of the key assumption that linear sections of a data series are reflected by stable parameters across the rolling estimates, a property that is often applied in financial statistics to evaluate model stability and make forward predictions on time-series data (see Zivot and Wang 2006). We use kernel density estimation (KDE) techniques, often applied in various inference procedures such as machine learning, pattern recognition and computer vision, to automatically aggregate stable (i.e. linear) segments as they naturally form one or more local maximums (“modes”) in the probability density estimate.</p>
<p>KDE requires no assumption that the data is from a parametric family, and learns the shape of the density automatically without supervision. KDE can be expressed as: <span class="math display">\[\hat{f}(x) = \frac{1}{nh^d}\sum_{i = 1}^{n} K \left(\frac{x - X_i}{h} \right)\]</span> where <span class="math inline">\(f\)</span> is the density function from an unknown distribution <span class="math inline">\(P\)</span> for <span class="math inline">\(X_1,...,X_n\)</span>, <span class="math inline">\(K\)</span> is the kernel function and <span class="math inline">\(h\)</span> is the optimal smoothing bandwidth. The smoothing bandwidth is computed using the solve-the-equation <em>plug-in</em> method (Sheather et al. 1996, Sheather and Jones 1991) which works well with multimodal or non-normal densities (Raykar and Duraiswami 2006).</p>
<!-- The smoothing bandwidth $h$ is computed using an adjusted kernel bandwidth selector based on Silvermans "rule of thumb" (Silverman, 1986): $$h = \left(\frac{4\hat{\sigma}^5}{3n} \right)^{\frac{1}{5}} \approx 1.06\hat{\sigma}n^{-\frac{1}{5}}$$ where $\hat{\sigma}$ is the standard deviation of the samples and $n$ is the total number of samples.  -->
<p>We then use <span class="math inline">\(h\)</span> to select all values in the rolling regression output that match the range of values around each mode (<span class="math inline">\(\theta_n\)</span>) of the KDE (i.e. <span class="math inline">\(\theta_n \pm h\)</span>). These rolling estimates are grouped and ranked by size, and the upper and lower bounds of the data windows they represent are used to re-select the linear segment of the original data series. The rolling estimates are then discarded while the detected data segments are analysed using linear regression.</p>
</div>
<div id="adjusting-the-width-of-rolling-regressions" class="section level2">
<h2 class="hasAnchor">
<a href="#adjusting-the-width-of-rolling-regressions" class="anchor"></a>Adjusting the width of rolling regressions</h2>
<p>By default, <code>auto_rate</code> rolling regression uses a window value in rows of <code>0.2</code> multiplied by the total length of the number of samples, that is across a rolling window of 20% of the data. This can be changed using the <code>width</code> argument to a different proportion relative to the total size of the data (e.g. <code>width = 0.1</code>). If not a value between 0 and 1, the <code>width</code> by default equates to a fixed value in rows (e.g. <code>width = 2000, by = "row"</code>), or can be set as a fixed value in the time metric (<code>width = 3000, by = "time"</code>).</p>
<p>It is important to note that the <code>width</code> determines the exact width of the data segments produced for <code>max</code>, <code>min</code> and <code>interval</code> rates. This allows the user to consistently report results across experiments, such as reporting the maximum or minimum rates sustained over a specific time period.</p>
<p>Importantly however, the <code>width</code> does <em>not</em> restrict the maximum width of the segments produced for linear detection. <strong>We advise users to use caution when changing the <code>width</code> argument if using <code>method = "linear"</code>.</strong> Choosing an inappropriate width value tends to over-fit the data for rolling regression.</p>
<p>Below, we show the differences in the shape of the rolling regressions when using the default <code>width = 0.2</code> versus a value of <code>0.6</code> with the dataset <code>sardine.rd</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># Perform linear detection; default width (when not specified) is 0.2:</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>normx &lt;-<span class="st"> </span><span class="kw"><a href="../reference/auto_rate.html">auto_rate</a></span>(sardine.rd, <span class="dt">plot =</span> <span class="ot">FALSE</span>)</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co"># Perform linear detection using manual width of 0.6:</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>overx &lt;-<span class="st"> </span><span class="kw"><a href="../reference/auto_rate.html">auto_rate</a></span>(sardine.rd, <span class="dt">plot =</span> <span class="ot">FALSE</span>, <span class="dt">width =</span> <span class="fl">.6</span>)</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co"># Plot ONLY the rolling regression plots for comparison:</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw"><a href="https://rdrr.io/r/graphics/par.html">par</a></span>(<span class="dt">mfrow =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="dt">mai =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="fl">0.4</span>, <span class="fl">0.4</span>, <span class="fl">0.3</span>, <span class="fl">0.3</span>), <span class="dt">ps =</span> <span class="dv">10</span>,</span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="dt">cex =</span> <span class="dv">1</span>, <span class="dt">cex.main =</span> <span class="dv">1</span>)</span>
<span id="cb1-10"><a href="#cb1-10"></a>respR<span class="op">:::</span><span class="kw">plot.auto_rate</span>(normx, <span class="dt">choose =</span> <span class="dv">3</span>) <span class="co">## CHANGE WHEN IN MASTER BACK TO REGULAR PLOT</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co">#&gt; </span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co">#&gt; # plot.auto_rate # ----------------------</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="co">#&gt; Done.</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>respR<span class="op">:::</span><span class="kw">plot.auto_rate</span>(overx, <span class="dt">choose =</span> <span class="dv">3</span>)</span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="co">#&gt; </span></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="co">#&gt; # plot.auto_rate # ----------------------</span></span></code></pre></div>
<p><img src="auto_rate_files/figure-html/rollreg_demo-1.png" width="576"></p>
<pre><code>#&gt; Done.</code></pre>
<p>Under perfectly linear conditions, we would expect a rolling regression output plot such as this to consist of a straight, horizontal line. Since KDE automatically aggregates stable values, a poor selection of the <code>width</code> value may result in a badly-characterised rolling estimate output. In the example presented above, while the default width showed a pattern of relative stability in rate after 3,000 seconds, that information was lost when a <code>width</code> of <code>0.6</code> was used. Thus, the KDE technique would not have had the appropriate information necessary to correctly detect any linear patterns in the same data.</p>
</div>
<div id="most-linear-rates" class="section level2">
<h2 class="hasAnchor">
<a href="#most-linear-rates" class="anchor"></a>Most linear rates</h2>
<p>By default, <code><a href="../reference/auto_rate.html">auto_rate()</a></code> identifies the <em>most linear</em> region of the data (i.e. <code>method = "linear"</code>):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/auto_rate.html">auto_rate</a></span>(sardine.rd)</span></code></pre></div>
<p><img src="auto_rate_files/figure-html/unnamed-chunk-2-1.png" width="576"></p>
<p>This represents the most consistently linear region, that is most consistent rate observed during the experiment. It does this in a statistically rigorous manner, which removes observer subjectivity from choosing which rate is most appropriate to report in their results. It calculates these <em>most linear</em> rates across all possible data window widths, so this also removes the need to the user to specify this. It is a statistically robust way of indentifying and reporting consistent rates in respirometry data.</p>
<div id="exploring-the-results" class="section level3">
<h3 class="hasAnchor">
<a href="#exploring-the-results" class="anchor"></a>Exploring the results</h3>
<p>Generally, <code>auto_rate</code> identifies multiple linear regions and ranks them, and by default the highest ranked one is returned. However, as a fully automated, unsupervised method of identifying linear data it is fallible, and the results should always be inspected and explored. In this case the function has identified a total of 46 linear regions:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw"><a href="https://rdrr.io/r/base/print.html">print</a></span>(x)</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co">#&gt; </span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">#&gt; # auto_rate # ---------------------------</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">#&gt; Data is subset by row using width of 1502 </span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">#&gt; Rates were computed using 'linear' method</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">#&gt; 46 linear regions detected in the kernel density estimate</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">#&gt; </span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co">#&gt; Rank 1 of 46 :</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co">#&gt; Rate: -0.000660665 </span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co">#&gt; R.sq: 0.982 </span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co">#&gt; Rows: 3659 to 6736 </span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co">#&gt; Time: 3658 to 6735</span></span></code></pre></div>
<p>The first rate result looks good: it has a high <code>rsq</code>, is sustained over a duration of 50 minutes, and the rate value of -0.00066 is consistent with the other results. However in some cases, other ranked results may better answer the question being asked of the data, in this case be more representative of the metabolic rate metric being investigated.</p>
<p>All ranked results can be inspected in the <code>$summary</code> data frame:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw"><a href="https://rdrr.io/r/utils/head.html">head</a></span>(x<span class="op">$</span>summary, <span class="dt">n =</span> <span class="dv">10</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co">#&gt;      row endrow time endtime intercept_b0       rate_b1   rsq</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">#&gt;  1: 3659   6736 3658    6735     94.94254 -0.0006606650 0.982</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">#&gt;  2: 2242   5543 2241    5542     95.06588 -0.0006875585 0.986</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">#&gt;  3: 3628   7164 3627    7163     94.94880 -0.0006618145 0.987</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">#&gt;  4: 1578   4236 1577    4235     95.13136 -0.0007082357 0.979</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">#&gt;  5: 1947   4236 1946    4235     95.12355 -0.0007059132 0.971</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co">#&gt;  6: 1578   4236 1577    4235     95.13136 -0.0007082357 0.979</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co">#&gt;  7:  601   1969  600    1968     95.73380 -0.0010465248 0.961</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="co">#&gt;  8: 1578   4196 1577    4195     95.13302 -0.0007089134 0.978</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co">#&gt;  9: 5050   6613 5049    6612     94.75424 -0.0006283802 0.929</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="co">#&gt; 10: 5123   6507 5122    6506     94.70348 -0.0006194828 0.912</span></span></code></pre></div>
<p>Here, the 7th ranked result, while being a highly linear region, is conspicuously higher in rate value and occurs close to the start of the experiment. If we were examining standard or basal metabolic rates, we would probably want to exclude this one, as it suggests the specimen has not acclimated to the chamber. So an investigator may choose to use a result from the top ranked one, or select several and take a mean of the resulting rates. For example, they may exclude all below a certain <code>rsq</code>, or only the top nth percentile of results, or exclude those from the early stages of the experiment. A function to do this is in preparation, but for now the results can be explored using the <code>$summary</code> data frame, and additional results can be printed and plotted using <code>pos</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw"><a href="https://rdrr.io/r/base/print.html">print</a></span>(x, <span class="dt">pos =</span> <span class="dv">5</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co">#&gt; </span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">#&gt; # auto_rate # ---------------------------</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">#&gt; Data is subset by row using width of 1502 </span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">#&gt; Rates were computed using 'linear' method</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">#&gt; 46 linear regions detected in the kernel density estimate</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="co">#&gt; </span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="co">#&gt; Rank 5 of 46 :</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co">#&gt; Rate: -0.0007059132 </span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="co">#&gt; R.sq: 0.971 </span></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="co">#&gt; Rows: 1947 to 4236 </span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co">#&gt; Time: 1946 to 4235</span></span>
<span id="cb6-13"><a href="#cb6-13"></a></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="kw"><a href="https://rdrr.io/r/graphics/plot.html">plot</a></span>(x, <span class="dt">pos =</span> <span class="dv">5</span>)</span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co">#&gt; </span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="co">#&gt; # plot.auto_rate # ----------------------</span></span></code></pre></div>
<p><img src="auto_rate_files/figure-html/unnamed-chunk-5-1.png" width="576"></p>
<pre><code>#&gt; Done.</code></pre>
<p>Any rate value determined after this can be saved as a variable, or entered manually as a value in the <code>adjust_rate</code> and <code>convert_rate</code> steps.</p>
</div>
</div>
<div id="minimum-and-maximum-rates" class="section level2">
<h2 class="hasAnchor">
<a href="#minimum-and-maximum-rates" class="anchor"></a>Minimum and maximum rates</h2>
<p><code><a href="../reference/auto_rate.html">auto_rate()</a></code> can also be used to detect the <em>maximum</em> and <em>minimum</em> rates over a fixed sample width. This can be a proportion of the dataset (e.g. the default <code>width = 0.2, by = "row"</code>, or 20% of the data), or if not between 0 and 1 represents a fixed row width (e.g. <code>width = 400, by = "row"</code>) or fixed period of time (e.g. <code>width = 600, by = "time"</code>). This allows for consistent reporting of respirometry results, such as the maximum or minimum rates sustained over a specified time period.</p>
<p>Note that <code>"by = row"</code> is considerably faster. Specifying a <code>time</code> window is telling <code><a href="../reference/auto_rate.html">auto_rate()</a></code> that the time data may have gaps or not be evenly spaced, and so the function calculates each (in this example) 600 second width using the raw time <em>values</em>, rather than assuming a specific row width represents the same time window, a less computationally intensive process. If your data is without gaps and evenly spaced with regards to time, <code>by = row</code> and the correct row <code>width</code> to represent the time window you want will be much faster.</p>
<div id="maximum-rates" class="section level3">
<h3 class="hasAnchor">
<a href="#maximum-rates" class="anchor"></a>Maximum rates</h3>
<p>Here we want to know the maximum rates sustained over 10 minutes, or 600s, in the <code>sardine.rd</code> data. Since in these data, O2 data is recorded every second and <code><a href="../reference/inspect.html">inspect()</a></code> tells us the time data is gapless and evenly spaced, we can simply specify width in the same number of rows:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/inspect.html">inspect</a></span>(sardine.rd)</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">#&gt; No issues detected while inspecting data frame.</span></span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>results &lt;-<span class="st"> </span><span class="kw"><a href="../reference/auto_rate.html">auto_rate</a></span>(x, <span class="dt">width =</span> <span class="dv">600</span>, <span class="dt">by =</span> <span class="st">"row"</span>, <span class="dt">method =</span> <span class="st">"max"</span>)</span></code></pre></div>
<p><img src="auto_rate_files/figure-html/unnamed-chunk-7-1.png" width="576"></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw"><a href="https://rdrr.io/r/utils/head.html">head</a></span>(results<span class="op">$</span>summary, <span class="dt">n =</span> <span class="dv">10</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co">#&gt;     row endrow time endtime intercept_b0      rate_b1       rsq</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co">#&gt;  1: 795   1394  794    1393     95.90557 -0.001193478 0.8589309</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co">#&gt;  2: 796   1395  795    1394     95.90576 -0.001193478 0.8589309</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="co">#&gt;  3: 792   1391  791    1390     95.90540 -0.001193245 0.8588905</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="co">#&gt;  4: 791   1390  790    1389     95.90536 -0.001193084 0.8588811</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="co">#&gt;  5: 801   1400  800    1399     95.90508 -0.001192889 0.8588085</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="co">#&gt;  6: 775   1374  774    1373     95.90217 -0.001192367 0.8641257</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="co">#&gt;  7: 794   1393  793    1392     95.90368 -0.001191776 0.8585386</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="co">#&gt;  8: 797   1396  796    1395     95.90392 -0.001191776 0.8585386</span></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="co">#&gt;  9: 793   1392  792    1391     95.90374 -0.001191698 0.8585342</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="co">#&gt; 10: 798   1397  797    1396     95.90370 -0.001191698 0.8585342</span></span></code></pre></div>
<p>Note, how the returned rates are ordered. The top result is the highest <em>absolute</em> rate, but because it is negative is <em>numerically</em> the lowest. Therefore, care should be taken if using this function to examine oxygen <em>production</em> such as in studies of plant photosynthesis, as maximum and minimum rates may be ordered differently.</p>
</div>
<div id="minimum-rates" class="section level3">
<h3 class="hasAnchor">
<a href="#minimum-rates" class="anchor"></a>Minimum rates</h3>
<p>We can similarly find the minimum rate over 10 minutes, and here we will save the output:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>min_rate &lt;-<span class="st"> </span><span class="kw"><a href="../reference/auto_rate.html">auto_rate</a></span>(sardine.rd, <span class="dt">width =</span> <span class="dv">600</span>, <span class="dt">method =</span> <span class="st">"min"</span>)</span></code></pre></div>
<p><img src="auto_rate_files/figure-html/unnamed-chunk-9-1.png" width="576"></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw"><a href="https://rdrr.io/r/base/print.html">print</a></span>(min_rate)</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="co">#&gt; </span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co">#&gt; # auto_rate # ---------------------------</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="co">#&gt; Data is subset by row using width of 600 </span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="co">#&gt; Rates were computed using 'min' method</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="co">#&gt; </span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="co">#&gt; Rank 1 of 6914 :</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="co">#&gt; Rate: -0.0005399376 </span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="co">#&gt; R.sq: 0.58528 </span></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="co">#&gt; Rows: 2260 to 2859 </span></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="co">#&gt; Time: 2259 to 2858</span></span></code></pre></div>
</div>
<div id="additional-ranked-results" class="section level3">
<h3 class="hasAnchor">
<a href="#additional-ranked-results" class="anchor"></a>Additional ranked results</h3>
<p>Note that <code>auto_rate</code> objects contain the results of <strong><em>all</em></strong> regressions for the specified <code>width</code>. By default, the first ranked (i.e. most maximum or minimum) result is returned, but others and their locations can be examined using the <code>summary</code> command:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw"><a href="https://rdrr.io/r/base/summary.html">summary</a></span>(min_rate)</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co">#&gt; Regressions : 6914 | Results : 6914 | Method : min | Roll width : 600 | Roll type : row </span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co">#&gt; </span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="co">#&gt; === Summary of Results ===</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="co">#&gt; </span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="co">#&gt;        row endrow time endtime intercept_b0       rate_b1       rsq</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="co">#&gt;    1: 2260   2859 2259    2858     94.69693 -0.0005399376 0.5852845</span></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="co">#&gt;    2: 2259   2858 2258    2857     94.69981 -0.0005410793 0.5864181</span></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="co">#&gt;    3: 2258   2857 2257    2856     94.70265 -0.0005422043 0.5875352</span></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="co">#&gt;    4: 5844   6443 5843    6442     94.23211 -0.0005430376 0.6155883</span></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="co">#&gt;    5: 2261   2860 2260    2859     94.70663 -0.0005437765 0.5875985</span></span>
<span id="cb13-12"><a href="#cb13-12"></a><span class="co">#&gt;   ---                                                              </span></span>
<span id="cb13-13"><a href="#cb13-13"></a><span class="co">#&gt; 6910:  801   1400  800    1399     95.90508 -0.0011928894 0.8588085</span></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="co">#&gt; 6911:  791   1390  790    1389     95.90536 -0.0011930839 0.8588811</span></span>
<span id="cb13-15"><a href="#cb13-15"></a><span class="co">#&gt; 6912:  792   1391  791    1390     95.90540 -0.0011932450 0.8588905</span></span>
<span id="cb13-16"><a href="#cb13-16"></a><span class="co">#&gt; 6913:  795   1394  794    1393     95.90557 -0.0011934783 0.8589309</span></span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="co">#&gt; 6914:  796   1395  795    1394     95.90576 -0.0011934783 0.8589309</span></span></code></pre></div>
<p>Particular ranked results can be examined or extracted via the <code>plot</code> and <code>summary</code> commands, using the <code>pos</code> (for position) operator:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">## Second most minimum rate detected</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>respR<span class="op">:::</span><span class="kw">plot.auto_rate</span>(min_rate, <span class="dt">pos =</span> <span class="dv">2</span>)</span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="co">#&gt; </span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="co">#&gt; # plot.auto_rate # ----------------------</span></span></code></pre></div>
<p><img src="auto_rate_files/figure-html/unnamed-chunk-11-1.png" width="576"></p>
<pre><code><a href="https://rdrr.io/r/base/summary.html">#&gt; Done.
summary(min_rate, pos = 2)
#&gt; Regressions : 6914 | Results : 6914 | Method : min | Roll width : 600 | Roll type : row 
#&gt; 
#&gt; === Summary of Ranked  2 Result ===
#&gt; 
#&gt;     row endrow time endtime intercept_b0       rate_b1       rsq
#&gt; 1: 2259   2858 2258    2857     94.69981 -0.0005410793 0.5864181</a></code></pre>
<p>Note, the output objects of the <code>max</code> and <code>min</code> are essentially identical, the only difference being the results are ordered descending or ascending by rate, respectively. Therefore in this example, the <em>maximum</em> rate (i.e. <em>least</em> minimum) can be found by extracting the <em>last</em> result.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw"><a href="https://rdrr.io/r/base/print.html">print</a></span>(min_rate, <span class="kw"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span>(min_rate<span class="op">$</span>summary))</span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="co">#&gt; </span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co">#&gt; # auto_rate # ---------------------------</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co">#&gt; Data is subset by row using width of 600 </span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="co">#&gt; Rates were computed using 'min' method</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="co">#&gt; </span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="co">#&gt; Rank 6914 of 6914 :</span></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="co">#&gt; Rate: -0.001193478 </span></span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="co">#&gt; R.sq: 0.85893 </span></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="co">#&gt; Rows: 796 to 1395 </span></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="co">#&gt; Time: 795 to 1394</span></span></code></pre></div>
<!-- ### Interval rate -->
<!-- ```{r} -->
<!-- x <- auto_rate(sardine.rd, width = 1000, method = "interval") -->
<!-- print(x, 4)  # select the 4th interval result -->
<!-- ``` -->
<!-- ### Detecting and measuring linear regions -->
<!-- The function `auto_rate()` performs automatic detection of linear data by default: -->
<!-- ```{r} -->
<!-- x <- auto_rate(sardine.rd) -->
<!-- ``` -->
</div>
</div>
<div id="summary-of-when-to-use-different-auto_rate-options" class="section level2">
<h2 class="hasAnchor">
<a href="#summary-of-when-to-use-different-auto_rate-options" class="anchor"></a>Summary of when to use different <code>auto_rate</code> options</h2>
<div id="method-linear" class="section level3">
<h3 class="hasAnchor">
<a href="#method-linear" class="anchor"></a><code>method = "linear"</code>
</h3>
<p>In ‘steady state’ experiments. That is, when you are looking for the most <em>consistent</em> or <em>representative rates</em> for what the specimen is experiencing. This could represent routine metabolic rate, or in the case of an animal under constant excercise a consistent active metabolic rate. The default <code>width = 0.2</code> is used and in testing gives good results; users should be careful about changing this value to avoid overfitting (see section above).</p>
</div>
<div id="method-max" class="section level3">
<h3 class="hasAnchor">
<a href="#method-max" class="anchor"></a><code>method = "max"</code>
</h3>
<p>When your specimen is active at some point during the experiment, or has been exercised and placed in a respirometer, and you want to know its <em>maximum</em> rate over a specific time period or row width. The default is <code>width = 0.2, by = "row"</code> (0.2 of total row number) or it can be specified in actual row or time width, e.g. <code>width = 300, by = "row"</code>, <code>width = 600, by = "time"</code>). This should be carefully chosen, and consistent if you are comparing specimens.</p>
</div>
<div id="method-min" class="section level3">
<h3 class="hasAnchor">
<a href="#method-min" class="anchor"></a><code>method = "min"</code>
</h3>
<p>Similarly, when your specimen is inactive, quiescent, dormant, etc., and you want to know the lowest rates over a specified time period. This is often representative of resting, basal or standard metabolic rates. Again, this necessarily requires a row or time window (<code>width</code>) to be specified, which should be carefully chosen, and consistent if you are comparing specimens.</p>
</div>
<div id="method-interval" class="section level3">
<h3 class="hasAnchor">
<a href="#method-interval" class="anchor"></a><code>method = "interval"</code>
</h3>
<p>This is chiefly for comparison with historical data, or if you have a specific reason to specify non-overlapping regressions. For example, in P<sub>crit</sub> measurements, it is common for users to generate rate~O<sub>2</sub> data by interval-based regressions.</p>
</div>
</div>
<div id="when-not-to-use-auto_rate" class="section level2">
<h2 class="hasAnchor">
<a href="#when-not-to-use-auto_rate" class="anchor"></a>When <em>not</em> to use <code>auto_rate</code>
</h2>
<ul>
<li>
<strong>Flowthrough respirometry data</strong><br>
See <code><a href="../reference/calc_rate.ft.html">calc_rate.ft()</a></code>. This respirometry method is currently unsupported in <code>auto_rate</code>, but it is in our plans to add this.</li>
<li>
<strong>Intermittent flow respirometry, without some subsetting or specification of measurement periods</strong><br>
While we have had generally good results using <code><a href="../reference/auto_rate.html">auto_rate()</a></code> on intermittent-flow data, there is a strong possibility flush periods will confuse the algorithms. The <code>subset_data</code> fuction is ideal for specifying the data regions of interest, or see <a href="https://januarharianto.github.io/respR/articles/intermittent2.html">Intermittent-flow respirometry: Complex example</a> for how to use <code>auto_rate</code> with these data. And as always, inspect output plots to ensure data locations are relevant.</li>
</ul>
</div>
<div id="further-processing" class="section level2">
<h2 class="hasAnchor">
<a href="#further-processing" class="anchor"></a>Further processing</h2>
<p>Saved <code><a href="../reference/auto_rate.html">auto_rate()</a></code> objects can be passed to subsequent <code>respR</code> functions for further processing, such as <code><a href="../reference/adjust_rate.html">adjust_rate()</a></code> to correct for background respiration, or <code><a href="../reference/convert_rate.html">convert_rate()</a></code> to convert to final O<sub>2</sub> uptake rates.</p>
</div>
<div id="examples" class="section level2">
<h2 class="hasAnchor">
<a href="#examples" class="anchor"></a>Examples</h2>
<p>Examples are available in the <a href="https://januarharianto.github.io/respR/reference/index.html">list of functions</a>. You may also run <code><a href="https://rdrr.io/r/utils/data.html">data(package = "respR")</a></code> in the R console to access some examples in the help file.</p>
<div id="references" class="section level3">
<h3 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h3>
<p>Jones, M. C., Marron, J. S., &amp; Sheather, S. J. (1996). A Brief Survey of Bandwidth Selection for Density Estimation. Journal of the American Statistical Association, 91(433), 401–407. <a href="doi:10.1080/01621459.1996.10476701" class="uri">doi:10.1080/01621459.1996.10476701</a></p>
<p>Olito, C., White, C. R., Marshall, D. J., &amp; Barneche, D. R. (2017). Estimating monotonic rates from biological data using local linear regression. The Journal of Experimental Biology, jeb.148775-jeb.148775. <a href="doi:10.1242/jeb.148775" class="uri">doi:10.1242/jeb.148775</a></p>
<p>Raykar, V., &amp; Duraiswami, R. (2006). Fast optimal bandwidth selection for kernel density estimation. In Proceedings of the Sixth SIAM International Conference on Data Mining (Vol. 2006). <a href="doi:10.1137/1.9781611972764.53" class="uri">doi:10.1137/1.9781611972764.53</a></p>
<p>Sheather, S. J., &amp; Jones, M. C. (1991). A Reliable Data-Based Bandwidth Selection Method for Kernel Density Estimation. Journal of the Royal Statistical Society. Series B (Methodological), 53(3), 683–690.</p>
<p>Zivot, E., &amp; Wang, J. (2006). Modeling Financial Time Series with S-PLUS (2nd ed.). New York: Springer-Verlag.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">

        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#overview">Overview</a></li>
      <li><a href="#rolling-linear-regression">Rolling linear regression</a></li>
      <li><a href="#kernel-density-estimation">Kernel density estimation</a></li>
      <li><a href="#adjusting-the-width-of-rolling-regressions">Adjusting the width of rolling regressions</a></li>
      <li><a href="#most-linear-rates">Most linear rates</a></li>
      <li><a href="#minimum-and-maximum-rates">Minimum and maximum rates</a></li>
      <li><a href="#summary-of-when-to-use-different-auto_rate-options">Summary of when to use different <code>auto_rate</code> options</a></li>
      <li><a href="#when-not-to-use-auto_rate">When <em>not</em> to use <code>auto_rate</code></a></li>
      <li><a href="#further-processing">Further processing</a></li>
      <li><a href="#examples">Examples</a></li>
      </ul>
</div>
      </div>

</div>



      <footer><div class="copyright">
  <p>Developed by Januar Harianto, Nicholas Carey.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
